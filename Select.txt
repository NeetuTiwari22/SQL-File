Select  
1.Find the country that start with Y.
select name
from world
where name like 'Y%';
2.Find the countries that end with y.
select name from world
  where name like '%y';
3.Find the countries that contain the letter x.
select name from world
  where name like '%x%';
4.Find the countries that end with land.
select name from world
  where name like '%land';
5.Find the countries that start with C and end with ia.
select name from world
  where name LIKE 'C%ia';

-- classroom data
create database classroom;
use classroom;
CREATE TABLE classroom (
rollno int8 PRIMARY KEY,
name varchar(50) NOT NULL,
house char(12) NOT NULL,
grade char(1) );

INSERT INTO classroom (rollno, name, house, grade)
VALUES
(1, 'Sam', 'Akash', 'B'),
(2, 'Ram', 'Agni', 'A'),
(3, 'Shyam', 'Jal','B'),
(4, 'Sundar', 'Agni', 'A'),
(5, 'Ram', 'Yayu', 'B');

select * from classroom;
-- where clause
select name from classroom 
where grade = 'a';
-- bitwise operators
select name from classroom 
where grade = 'a' and rollno >3 ;

use sakila;
select * from customer;
-- order by clause
select * from customer
order by first_name desc;

-- Limit clause
select * from customer
limit 5; 

-- joins  inner joins
CREATE DATABASE join_demo;
USE join_demo;
CREATE TABLE Customer (
    customer_id INT PRIMARY KEY,
    name VARCHAR(50)
);

INSERT INTO Customer (customer_id, name) VALUES
(1, 'Mary'),
(2, 'John'),
(3, 'Alice'),
(4, 'David');

CREATE TABLE Payment (
    payment_id INT PRIMARY KEY,
    customer_id INT,
    amount DECIMAL(8,2),
    payment_date DATE,
    FOREIGN KEY (customer_id) REFERENCES Customer(customer_id)
);

INSERT INTO Payment (payment_id, customer_id, amount, payment_date) VALUES
(101, 1, 5.99, '2025-08-01'),
(102, 2, 9.99, '2025-08-02'),
(103, 1, 2.50, '2025-08-05'),
(104, 2, 4.50, '2025-08-07');

select * from customer;
select * from payment;
-- inner join
select c.customer_id,c.name,p.customer_id,p.payment_id,p.amount from customer c
inner join payment p 
on c.customer_id=p.customer_id;

-- left join
select c.customer_id,c.name,p.customer_id,p.payment_id,p.amount from customer c
left join payment p 
on c.customer_id=p.customer_id;

-- right join
select c.customer_id,c.name,p.customer_id,p.payment_id,p.amount from customer c
right join payment p 
on c.customer_id=p.customer_id;

-- full join
SELECT c.customer_id, c.name, p.payment_id, p.amount
FROM Customer c
LEFT JOIN Payment p ON c.customer_id = p.customer_id
UNION
SELECT c.customer_id, c.name, p.payment_id, p.amount
FROM Customer c
RIGHT JOIN Payment p ON c.customer_id = p.customer_id;
-- self join
CREATE TABLE Employee (
    emp_id INT PRIMARY KEY,
    emp_name VARCHAR(50),
    manager_id INT
);
INSERT INTO Employee VALUES
(1, 'Alice', NULL),   
(2, 'Bob', 1),        
(3, 'Charlie', 1),    
(4, 'David', 2),      
(5, 'Eva', 2);        
select * from employee;
select e.emp_name,e.emp_id employee,
m.emp_name manager
from employee e
join employee m
on e.manager_id=m.emp_id;

-- cros join
use join_demo;
select * from customer;
select * from employee;
select * from payment;
select c.name,c.customer_id,p.payment_id,p.amount
from customer as c
cross join payment as p
order by c.customer_id;

-- group by statement
use join_demo;
select * from payment;
select customer_id , sum(amount) as sum
from payment p
group by customer_id 
order by sum; 

-- having clause
use join_demo;
CREATE TABLE Sales (
    sale_id INT PRIMARY KEY,
    product VARCHAR(50),
    category VARCHAR(50),
    amount DECIMAL(8,2)
);
INSERT INTO Sales (sale_id, product, category, amount) VALUES
(1, 'Book', 'Stationery', 200),
(2, 'Pen', 'Stationery', 50),
(3, 'Bag', 'Stationery', 500),
(4, 'Laptop', 'Electronics', 45000),
(5, 'Mouse', 'Electronics', 800),
(6, 'Phone', 'Electronics', 30000),
(7, 'Shirt', 'Clothing', 1200),
(8, 'Jeans', 'Clothing', 2200);
select * from sales;

select category,sum(amount)
from sales
group by category
having sum(amount)>=5000;

use world;
-- if else
select code , name ,if(name='aruba','hey','hello')  , indepyear from country ;
select code , name , 
if(name='aruba','Trror country',if(name='angola','Terroist','Tourism')), indepyear from country ; 
-- case
select code,name,
case
when name = 'aruba'then 'terror'
when name = 'angola'then 'terrorist'
else 'tourism'
end as 'state'
from country;
-- ifnull
select name,indepyear,ifnull(indepyear,0)from country;
select count(indepyear),count(ifnull(indepyear,0))from country;
select name,continent,nullif(length(name),length(continent))from country;
select * from country;

select code,name,
case
when population>200000 then 'Developed'
when name = 'angola'then 'Developed'
else 'Under developed'
end as 'Country Status'
from country;

-- subquery
use world;
select name, population from city where population>(select population from city where name = 'batna');
-- multi row query
select region,continent from country where continent = 'africa';

select name,population,continent from country where name in (select name from country where continent = 'europe');

use regex1;
select * from departments;
select * from employees;

select e1.empid,e1.empname,e1.deptid,e1.salary
from employees as e1
where e1.salary > 
(select avg(salary)from employees as e2
where e1.deptid = e2.deptid);

-- delete,insert,update,truncate
use sakila;
create table StudentAccess(id int, sname varchar(10) );
insert into StudentAccess value(9,"abc");
insert into StudentAccess (id,sname) value(19,'abc');
select * from StudentAccess;
insert into StudentAccess(id) values(11);
insert into StudentAccess(sname) values('yash');
update  StudentAccess set sname = 'raj'; -- all row are affected
update  StudentAccess set sname = 'abishek' where id=19; -- specified row updated
delete from studentaccess;-- all row are affected
delete from StudentAccess where id between 9 and 19; -- specified row delete
insert into StudentAccess (id,sname) value(23,'naina');
truncate table studentaccess; -- drop table + recreate structer

-- datatype tinyint
create table test18(id tinyint);
insert into test18(id) values(10);
insert into test18(id) values(-128);
insert into test18(id) values(-129); -- size is smaller 1 byte 2^8 256 (-128 to 127)
select * from test18;
-- unsigned = positive values
drop table test19;
create table test19(id tinyint unsigned); -- all positive number (range 255)
insert into test19(id) values(10);
insert into test19(id) values(-128);

-- DDL statement with constraint 
use regex1;
-- not null
create table test1 (id int, salary int not null); 
insert into test1 values(10,900);
insert into test1 values(10,null); -- error
select  * from test1;
drop table test1;
-- default
create table test2 (id int default 0, salary int not null); 
insert into test2 values(10,900);
insert into test2(salary) values  (1881); 
select  * from test2;

-- unique 
create table test3 (id int , salary int default 100 unique); 
insert into test3 values(10,900);
insert into test3 values(11,900);-- error here
insert into test3(id) values(9999999);
select  * from test3;

-- primary key constraint 
create table test4 (id int primary key , salary int ); 
insert into test4 values(10,900);
insert into test4 values(10,90012);-- error here
insert into test4(id) values(9999999);
select  * from test4;

--  creating foreign key 
drop table courses1;
create table courses1(course_id int primary key,cname varchar(20));
insert into courses1 values(10,'DSA'),(11,'PYTHON');
select * from courses1;

create table studentinfo (sid int primary key ,sname varchar(20),courseid int,
 foreign key (courseid) references courses1(course_id)); 
insert into studentinfo values(1,'tushar',10);
insert into studentinfo values(2,'aman',11);
select  * from studentinfo;

-- corrlated with cte
-- method 1
use regex1;
select * from employees;
select * from departments;
-- corrlated
-- find the employees name who have the salary gretar than the avg salary from department.
select empid,empname,salary,deptid
from employees as oute
where salary >
(select Avg(salary)from employees as inn
   where inn.deptid=oute.deptid);
   
   -- method = 2 using CTE -> common table name
   with xyz as 
    (select deptid,avg(salary)as dsalary from employees group by deptid)
	select e.empname,e.salary,xyz.dsalary 
     from xyz join employees as e
     where e.deptid=xyz.deptid and
     e.salary > xyz.dsalary;
     
-- set opetration
-- 1).union
use sakila;
select * from actor where actor_id between 1 and 3    
union 
select * from actor where actor_id between 3 and 5;   
-- 2).union all
select * from actor where actor_id between 1 and 3    
union all
select * from actor where actor_id between 3 and 5;   
-- 3).INTERSECT
select * from actor where actor_id between 1 and 3    
intersect 
select * from actor where actor_id between 3 and 5;   
-- 4).except
select * from actor where actor_id between 1 and 3    
except
select * from actor where actor_id between 3 and 5;   

-- recursive cte
with recursive cte as 
(select 1 as num
union
select num+1 from cte where num<6)
select * from cte;
-- factorial 
with recursive cte as 
(select 1 as i,1 as factorial
union
select i+1, factorial*(i+1) from cte where i<6)
select * from cte;

select * from employees2;

with recursive cte as 
(select employee_id,name,manager_id,1 as levels
from employees2 as e where manager_id is null
union
select etemp.employee_id,etemp.name,etemp.manager_id,levels+1
from employees2 as etemp join cte where etemp.manager_id=cte.employee_id)
select * from cte;

-- view
use sakila;
create view temp1 as(
select first_name,count(*) from actor where actor_id>10
group by first_name order by count(*) desc); 
select * from temp1;
-- security perpose
create view temp2 as
(select first_name,last_name from actor);
select * from temp2;

-- ctas -> crate table as select
create table factors as
(select actor_id,first_name,last_name from actor where actor_id<7);
select * from factors; 

create view temp4 as
(select first_name,last_name from factors);
insert into temp4 values("raj","sharma");
select * from temp4;
